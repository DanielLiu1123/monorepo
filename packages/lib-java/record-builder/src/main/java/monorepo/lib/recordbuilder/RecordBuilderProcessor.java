package monorepo.lib.recordbuilder;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.RecordComponentElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Elements;
import javax.lang.model.util.Types;
import javax.tools.Diagnostic;

/**
 * Annotation processor for generating builder classes for records annotated with {@link RecordBuilder}.
 *
 * @author Freeman
 * @since 2025/11/30
 */
@SupportedAnnotationTypes("monorepo.lib.recordbuilder.RecordBuilder")
@SupportedSourceVersion(SourceVersion.RELEASE_17)
public class RecordBuilderProcessor extends AbstractProcessor {

    private Filer filer;
    private Messager messager;
    private Elements elementUtils;
    private Types typeUtils;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.filer = processingEnv.getFiler();
        this.messager = processingEnv.getMessager();
        this.elementUtils = processingEnv.getElementUtils();
        this.typeUtils = processingEnv.getTypeUtils();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        for (Element element : roundEnv.getElementsAnnotatedWith(RecordBuilder.class)) {
            if (element.getKind() != ElementKind.RECORD) {
                messager.printMessage(
                        Diagnostic.Kind.ERROR, "@RecordBuilder can only be applied to records", element);
                continue;
            }

            TypeElement recordElement = (TypeElement) element;
            try {
                generateBuilder(recordElement);
            } catch (IOException e) {
                messager.printMessage(
                        Diagnostic.Kind.ERROR, "Failed to generate builder: " + e.getMessage(), recordElement);
            }
        }
        return true;
    }

    private void generateBuilder(TypeElement recordElement) throws IOException {
        String packageName = elementUtils.getPackageOf(recordElement).getQualifiedName().toString();
        String recordName = recordElement.getSimpleName().toString();
        String builderName = recordName + "Builder";

        ClassName recordClassName = ClassName.get(packageName, recordName);
        ClassName builderClassName = ClassName.get(packageName, builderName);

        List<? extends RecordComponentElement> components = recordElement.getRecordComponents();

        TypeSpec.Builder builderClassBuilder = TypeSpec.classBuilder(builderName)
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addJavadoc("Builder for {@link $T}.\n", recordClassName)
                .addJavadoc("<p>Generated by {@link RecordBuilder}.\n");

        // Add fields
        for (RecordComponentElement component : components) {
            TypeName fieldType = getBuilderFieldType(component);
            FieldSpec.Builder fieldBuilder =
                    FieldSpec.builder(fieldType, component.getSimpleName().toString(), Modifier.PRIVATE);

            // Add @Nullable annotation if the field is nullable
            if (isNullable(component)) {
                fieldBuilder.addAnnotation(getNullableAnnotation(component));
            }

            builderClassBuilder.addField(fieldBuilder.build());
        }

        // Add private constructor
        builderClassBuilder.addMethod(
                MethodSpec.constructorBuilder().addModifiers(Modifier.PRIVATE).build());

        // Add static of() method
        builderClassBuilder.addMethod(MethodSpec.methodBuilder("of")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(builderClassName)
                .addStatement("return new $T()", builderClassName)
                .build());

        // Add static from() method
        builderClassBuilder.addMethod(generateFromMethod(recordClassName, builderClassName, components));

        // Add setter methods (skip Collection and Map types, they use adder/putter methods)
        for (RecordComponentElement component : components) {
            if (!isCollection(component) && !isMap(component)) {
                builderClassBuilder.addMethod(generateSetterMethod(builderClassName, component));
            }
        }

        // Add collection methods for Collection and Map fields
        for (RecordComponentElement component : components) {
            if (isCollection(component)) {
                builderClassBuilder.addMethod(generateAddMethod(builderClassName, component));
                builderClassBuilder.addMethod(generateAddAllMethod(builderClassName, component));
            } else if (isMap(component)) {
                builderClassBuilder.addMethod(generatePutMethod(builderClassName, component));
                builderClassBuilder.addMethod(generatePutAllMethod(builderClassName, component));
            }
        }

        // Add clear methods for all fields
        for (RecordComponentElement component : components) {
            builderClassBuilder.addMethod(generateClearMethod(builderClassName, component));
        }

        // Add getter methods for all fields
        for (RecordComponentElement component : components) {
            builderClassBuilder.addMethod(generateGetterMethod(component));
        }

        // Add build() method
        builderClassBuilder.addMethod(generateBuildMethod(recordClassName, components));

        TypeSpec builderClass = builderClassBuilder.build();

        JavaFile javaFile = JavaFile.builder(packageName, builderClass).build();
        javaFile.writeTo(filer);
    }

    private TypeName getBuilderFieldType(RecordComponentElement component) {
        TypeMirror type = component.asType();

        if (isCollection(component)) {
            TypeMirror elementType = getTypeArgument(type, 0);
            ClassName interfaceClass = getCollectionInterfaceClass(type);
            // Preserve @Nullable annotations on element type
            TypeName elementTypeName = getTypeNameWithAnnotations(elementType);
            return ParameterizedTypeName.get(interfaceClass, elementTypeName);
        } else if (isMap(component)) {
            TypeMirror keyType = getTypeArgument(type, 0);
            TypeMirror valueType = getTypeArgument(type, 1);
            // Preserve @Nullable annotations on key/value types
            TypeName keyTypeName = getTypeNameWithAnnotations(keyType);
            TypeName valueTypeName = getTypeNameWithAnnotations(valueType);
            return ParameterizedTypeName.get(ClassName.get(Map.class), keyTypeName, valueTypeName);
        }

        return TypeName.get(type);
    }

    private MethodSpec generateFromMethod(
            ClassName recordClassName,
            ClassName builderClassName,
            List<? extends RecordComponentElement> components) {
        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("from")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(builderClassName)
                .addParameter(recordClassName, "record")
                .addStatement("$T builder = new $T()", builderClassName, builderClassName);

        for (RecordComponentElement component : components) {
            String fieldName = component.getSimpleName().toString();
            String getterName = fieldName;

            if (isCollection(component) || isMap(component)) {
                // For collections, create a defensive copy
                TypeMirror type = component.asType();
                if (isCollection(component)) {
                    Class<?> implClass = getCollectionImplClass(type);
                    methodBuilder.addStatement(
                            "builder.$L = record.$L() != null ? new $T<>(record.$L()) : null",
                            fieldName,
                            getterName,
                            implClass,
                            getterName);
                } else if (isMap(component)) {
                    methodBuilder.addStatement(
                            "builder.$L = record.$L() != null ? new $T<>(record.$L()) : null",
                            fieldName,
                            getterName,
                            HashMap.class,
                            getterName);
                }
            } else {
                methodBuilder.addStatement("builder.$L = record.$L()", fieldName, getterName);
            }
        }

        methodBuilder.addStatement("return builder");
        return methodBuilder.build();
    }

    private MethodSpec generateSetterMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "set" + capitalize(fieldName);
        TypeName fieldType = TypeName.get(component.asType());

        ParameterSpec.Builder paramBuilder = ParameterSpec.builder(fieldType, fieldName);

        // Add @Nullable annotation if the field is nullable
        boolean isFieldNullable = isNullable(component);
        if (isFieldNullable) {
            paramBuilder.addAnnotation(getNullableAnnotation(component));
        }

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName)
                .addParameter(paramBuilder.build());

        // Add null check for non-nullable, non-primitive fields
        if (!isFieldNullable && !isPrimitive(component)) {
            methodBuilder.addStatement(
                    "$T.requireNonNull($L, \"$L cannot be null\")", Objects.class, fieldName, fieldName);
        }

        methodBuilder.addStatement("this.$L = $L", fieldName, fieldName);
        methodBuilder.addStatement("return this");

        return methodBuilder.build();
    }

    private MethodSpec generateAddMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "add" + capitalize(fieldName);
        TypeMirror elementType = getTypeArgument(component.asType(), 0);
        Class<?> implClass = getCollectionImplClass(component.asType());

        ParameterSpec.Builder paramBuilder = ParameterSpec.builder(TypeName.get(elementType), "item");

        // Add @Nullable annotation if the element type is nullable
        if (isTypeNullable(elementType)) {
            paramBuilder.addAnnotation(getNullableAnnotationFromType(elementType));
        }

        return MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName)
                .addParameter(paramBuilder.build())
                .beginControlFlow("if (this.$L == null)", fieldName)
                .addStatement("this.$L = new $T<>()", fieldName, implClass)
                .endControlFlow()
                .addStatement("this.$L.add(item)", fieldName)
                .addStatement("return this")
                .build();
    }

    private MethodSpec generateAddAllMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "addAll" + capitalize(fieldName);
        TypeMirror elementType = getTypeArgument(component.asType(), 0);
        Class<?> implClass = getCollectionImplClass(component.asType());

        // Get TypeName with annotations preserved
        TypeName elementTypeName = getTypeNameWithAnnotations(elementType);
        TypeName collectionType =
                ParameterizedTypeName.get(ClassName.get(Iterable.class), elementTypeName);

        return MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName)
                .addParameter(collectionType, "items")
                .beginControlFlow("if (this.$L == null)", fieldName)
                .addStatement("this.$L = new $T<>()", fieldName, implClass)
                .endControlFlow()
                .beginControlFlow("for ($T item : items)", elementTypeName)
                .addStatement("this.$L.add(item)", fieldName)
                .endControlFlow()
                .addStatement("return this")
                .build();
    }

    private MethodSpec generatePutMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "put" + capitalize(fieldName);
        TypeMirror keyType = getTypeArgument(component.asType(), 0);
        TypeMirror valueType = getTypeArgument(component.asType(), 1);

        ParameterSpec.Builder keyParamBuilder = ParameterSpec.builder(TypeName.get(keyType), "key");
        ParameterSpec.Builder valueParamBuilder = ParameterSpec.builder(TypeName.get(valueType), "value");

        // Add @Nullable annotation if the key/value type is nullable
        if (isTypeNullable(keyType)) {
            keyParamBuilder.addAnnotation(getNullableAnnotationFromType(keyType));
        }
        if (isTypeNullable(valueType)) {
            valueParamBuilder.addAnnotation(getNullableAnnotationFromType(valueType));
        }

        return MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName)
                .addParameter(keyParamBuilder.build())
                .addParameter(valueParamBuilder.build())
                .beginControlFlow("if (this.$L == null)", fieldName)
                .addStatement("this.$L = new $T<>()", fieldName, HashMap.class)
                .endControlFlow()
                .addStatement("this.$L.put(key, value)", fieldName)
                .addStatement("return this")
                .build();
    }

    private MethodSpec generatePutAllMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "putAll" + capitalize(fieldName);
        TypeMirror keyType = getTypeArgument(component.asType(), 0);
        TypeMirror valueType = getTypeArgument(component.asType(), 1);

        // Get TypeName with annotations preserved
        TypeName keyTypeName = getTypeNameWithAnnotations(keyType);
        TypeName valueTypeName = getTypeNameWithAnnotations(valueType);
        TypeName mapType = ParameterizedTypeName.get(ClassName.get(Map.class), keyTypeName, valueTypeName);

        return MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName)
                .addParameter(mapType, "map")
                .beginControlFlow("if (this.$L == null)", fieldName)
                .addStatement("this.$L = new $T<>()", fieldName, HashMap.class)
                .endControlFlow()
                .addStatement("this.$L.putAll(map)", fieldName)
                .addStatement("return this")
                .build();
    }

    private MethodSpec generateClearMethod(ClassName builderClassName, RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "clear" + capitalize(fieldName);

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(builderClassName);

        // For primitive types, set to zero value; for reference types, set to null
        if (isPrimitive(component)) {
            String zeroValue = getPrimitiveZeroValue(component);
            methodBuilder.addStatement("this.$L = $L", fieldName, zeroValue);
        } else {
            methodBuilder.addStatement("this.$L = null", fieldName);
        }

        methodBuilder.addStatement("return this");
        return methodBuilder.build();
    }

    private String getPrimitiveZeroValue(RecordComponentElement component) {
        TypeKind kind = component.asType().getKind();
        return switch (kind) {
            case BOOLEAN -> "false";
            case BYTE, SHORT, INT, LONG -> "0";
            case CHAR -> "'\\0'";
            case FLOAT -> "0.0f";
            case DOUBLE -> "0.0";
            default -> throw new IllegalArgumentException("Not a primitive type: " + kind);
        };
    }

    private MethodSpec generateGetterMethod(RecordComponentElement component) {
        String fieldName = component.getSimpleName().toString();
        String methodName = "get" + capitalize(fieldName);
        // Use getBuilderFieldType to preserve type parameter annotations
        TypeName fieldType = getBuilderFieldType(component);

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(methodName)
                .addModifiers(Modifier.PUBLIC)
                .returns(fieldType)
                .addStatement("return this.$L", fieldName);

        // Add @Nullable annotation if the field is nullable
        if (isNullable(component)) {
            methodBuilder.addAnnotation(getNullableAnnotation(component));
        }

        return methodBuilder.build();
    }

    private MethodSpec generateBuildMethod(
            ClassName recordClassName, List<? extends RecordComponentElement> components) {
        MethodSpec.Builder methodBuilder =
                MethodSpec.methodBuilder("build").addModifiers(Modifier.PUBLIC).returns(recordClassName);

        // Add null checks for non-nullable, non-primitive, non-collection fields
        // Collections (Collection/Map) are allowed to be null and will be converted to empty collections
        for (RecordComponentElement component : components) {
            if (!isNullable(component)
                    && !isPrimitive(component)
                    && !isCollection(component)
                    && !isMap(component)) {
                String fieldName = component.getSimpleName().toString();
                methodBuilder.addStatement(
                        "$T.requireNonNull(this.$L, \"$L cannot be null\")",
                        Objects.class,
                        fieldName,
                        fieldName);
            }
        }

        // Build the return statement
        CodeBlock.Builder returnStatement = CodeBlock.builder().add("return new $T(", recordClassName);

        for (int i = 0; i < components.size(); i++) {
            RecordComponentElement component = components.get(i);
            String fieldName = component.getSimpleName().toString();

            if (i > 0) {
                returnStatement.add(", ");
            }

            // For collections, create immutable copies
            if (isCollection(component)) {
                TypeMirror elementType = getTypeArgument(component.asType(), 0);
                Class<?> implClass = getCollectionImplClass(component.asType());
                ClassName interfaceClass = getCollectionInterfaceClass(component.asType());
                boolean isFieldNullable = isNullable(component);

                if (isTypeNullable(elementType)) {
                    // List/Set.copyOf() don't support null elements, use Collections.unmodifiable* instead
                    String unmodifiableMethod =
                            interfaceClass.equals(ClassName.get(Set.class)) ? "unmodifiableSet" : "unmodifiableList";
                    if (isFieldNullable) {
                        // If the field itself is nullable, allow null instead of creating empty collection
                        returnStatement.add(
                                "this.$L != null ? $T.$L(new $T<>(this.$L)) : null",
                                fieldName,
                                java.util.Collections.class,
                                unmodifiableMethod,
                                implClass,
                                fieldName);
                    } else {
                        returnStatement.add(
                                "this.$L != null ? $T.$L(new $T<>(this.$L)) : $T.of()",
                                fieldName,
                                java.util.Collections.class,
                                unmodifiableMethod,
                                implClass,
                                fieldName,
                                interfaceClass);
                    }
                } else {
                    if (isFieldNullable) {
                        // If the field itself is nullable, allow null instead of creating empty collection
                        returnStatement.add(
                                "this.$L != null ? $T.copyOf(this.$L) : null",
                                fieldName,
                                interfaceClass,
                                fieldName);
                    } else {
                        returnStatement.add(
                                "this.$L != null ? $T.copyOf(this.$L) : $T.of()",
                                fieldName,
                                interfaceClass,
                                fieldName,
                                interfaceClass);
                    }
                }
            } else if (isMap(component)) {
                TypeMirror valueType = getTypeArgument(component.asType(), 1);
                boolean isFieldNullable = isNullable(component);

                if (isTypeNullable(valueType)) {
                    // Map.copyOf() doesn't support null values, use Collections.unmodifiableMap instead
                    if (isFieldNullable) {
                        // If the field itself is nullable, allow null instead of creating empty map
                        returnStatement.add(
                                "this.$L != null ? $T.unmodifiableMap(new $T<>(this.$L)) : null",
                                fieldName,
                                java.util.Collections.class,
                                HashMap.class,
                                fieldName);
                    } else {
                        returnStatement.add(
                                "this.$L != null ? $T.unmodifiableMap(new $T<>(this.$L)) : $T.of()",
                                fieldName,
                                java.util.Collections.class,
                                HashMap.class,
                                fieldName,
                                Map.class);
                    }
                } else {
                    if (isFieldNullable) {
                        // If the field itself is nullable, allow null instead of creating empty map
                        returnStatement.add(
                                "this.$L != null ? $T.copyOf(this.$L) : null",
                                fieldName,
                                Map.class,
                                fieldName);
                    } else {
                        returnStatement.add(
                                "this.$L != null ? $T.copyOf(this.$L) : $T.of()",
                                fieldName,
                                Map.class,
                                fieldName,
                                Map.class);
                    }
                }
            } else {
                returnStatement.add("this.$L", fieldName);
            }
        }

        returnStatement.add(")");
        methodBuilder.addStatement(returnStatement.build());

        return methodBuilder.build();
    }

    private boolean isCollection(RecordComponentElement component) {
        TypeMirror type = component.asType();
        if (type.getKind() != TypeKind.DECLARED) {
            return false;
        }

        TypeElement collectionType = elementUtils.getTypeElement("java.util.Collection");
        if (collectionType == null) {
            return false;
        }

        // Check if the type is assignable to Collection
        TypeMirror collectionTypeMirror = typeUtils.erasure(collectionType.asType());
        TypeMirror erasedType = typeUtils.erasure(type);
        return typeUtils.isAssignable(erasedType, collectionTypeMirror);
    }

    private Class<?> getCollectionImplClass(TypeMirror type) {
        if (type.getKind() != TypeKind.DECLARED) {
            return ArrayList.class;
        }

        TypeElement typeElement = (TypeElement) ((DeclaredType) type).asElement();
        String qualifiedName = typeElement.getQualifiedName().toString();

        // Determine the appropriate implementation class based on the interface
        if (qualifiedName.equals("java.util.Set") || qualifiedName.equals("java.util.LinkedHashSet")) {
            return LinkedHashSet.class;
        } else if (qualifiedName.equals("java.util.List") || qualifiedName.equals("java.util.ArrayList")) {
            return ArrayList.class;
        } else {
            // Default to ArrayList for other Collection types
            return ArrayList.class;
        }
    }

    private ClassName getCollectionInterfaceClass(TypeMirror type) {
        if (type.getKind() != TypeKind.DECLARED) {
            return ClassName.get(List.class);
        }

        TypeElement typeElement = (TypeElement) ((DeclaredType) type).asElement();
        String qualifiedName = typeElement.getQualifiedName().toString();

        // Return the appropriate interface class
        if (qualifiedName.equals("java.util.Set") || qualifiedName.equals("java.util.LinkedHashSet")) {
            return ClassName.get(Set.class);
        } else if (qualifiedName.equals("java.util.List") || qualifiedName.equals("java.util.ArrayList")) {
            return ClassName.get(List.class);
        } else {
            // Default to List for other Collection types
            return ClassName.get(List.class);
        }
    }

    private boolean isMap(RecordComponentElement component) {
        TypeMirror type = component.asType();
        if (type.getKind() != TypeKind.DECLARED) {
            return false;
        }

        TypeElement mapType = elementUtils.getTypeElement("java.util.Map");
        if (mapType == null) {
            return false;
        }

        // Check if the type is assignable to Map
        TypeMirror mapTypeMirror = typeUtils.erasure(mapType.asType());
        TypeMirror erasedType = typeUtils.erasure(type);
        return typeUtils.isAssignable(erasedType, mapTypeMirror);
    }

    private boolean isNullable(RecordComponentElement component) {
        // Check element annotations (for @Nullable on the parameter itself)
        boolean hasElementAnnotation = component.getAnnotationMirrors().stream()
                .anyMatch(annotation -> isNullableAnnotation(annotation));

        // Check type annotations (for @Nullable on the type, like jspecify)
        boolean hasTypeAnnotation = component.asType().getAnnotationMirrors().stream()
                .anyMatch(annotation -> isNullableAnnotation(annotation));

        return hasElementAnnotation || hasTypeAnnotation;
    }

    private boolean isNullableAnnotation(javax.lang.model.element.AnnotationMirror annotation) {
        String simpleName = annotation.getAnnotationType()
                .asElement()
                .getSimpleName()
                .toString();
        String qualifiedName = ((TypeElement) annotation.getAnnotationType().asElement())
                .getQualifiedName()
                .toString();
        // Support both simple name and common nullable annotations
        return simpleName.equals("Nullable")
                || qualifiedName.equals("org.jspecify.annotations.Nullable")
                || qualifiedName.equals("javax.annotation.Nullable")
                || qualifiedName.equals("jakarta.annotation.Nullable")
                || qualifiedName.equals("org.jetbrains.annotations.Nullable")
                || qualifiedName.equals("androidx.annotation.Nullable")
                || qualifiedName.equals("edu.umd.cs.findbugs.annotations.Nullable");
    }

    private boolean isPrimitive(RecordComponentElement component) {
        return component.asType().getKind().isPrimitive();
    }

    private boolean isTypeNullable(TypeMirror type) {
        return type.getAnnotationMirrors().stream()
                .anyMatch(annotation -> isNullableAnnotation(annotation));
    }

    private TypeName getTypeNameWithAnnotations(TypeMirror type) {
        TypeName typeName = TypeName.get(type);

        // If the type has @Nullable annotation, ensure it's preserved
        if (isTypeNullable(type)) {
            ClassName nullableAnnotation = getNullableAnnotationFromType(type);
            return typeName.annotated(AnnotationSpec.builder(nullableAnnotation).build());
        }

        return typeName;
    }

    private ClassName getNullableAnnotation(RecordComponentElement component) {
        // Check element annotations
        for (javax.lang.model.element.AnnotationMirror annotation : component.getAnnotationMirrors()) {
            if (isNullableAnnotation(annotation)) {
                TypeElement annotationType = (TypeElement) annotation.getAnnotationType().asElement();
                String packageName =
                        elementUtils.getPackageOf(annotationType).getQualifiedName().toString();
                String simpleName = annotationType.getSimpleName().toString();
                return ClassName.get(packageName, simpleName);
            }
        }

        // Check type annotations
        for (javax.lang.model.element.AnnotationMirror annotation :
                component.asType().getAnnotationMirrors()) {
            if (isNullableAnnotation(annotation)) {
                TypeElement annotationType = (TypeElement) annotation.getAnnotationType().asElement();
                String packageName =
                        elementUtils.getPackageOf(annotationType).getQualifiedName().toString();
                String simpleName = annotationType.getSimpleName().toString();
                return ClassName.get(packageName, simpleName);
            }
        }

        // Default fallback (shouldn't reach here if isNullable() returned true)
        return ClassName.get("org.jspecify.annotations", "Nullable");
    }

    private ClassName getNullableAnnotationFromType(TypeMirror type) {
        for (javax.lang.model.element.AnnotationMirror annotation : type.getAnnotationMirrors()) {
            if (isNullableAnnotation(annotation)) {
                TypeElement annotationType = (TypeElement) annotation.getAnnotationType().asElement();
                String packageName =
                        elementUtils.getPackageOf(annotationType).getQualifiedName().toString();
                String simpleName = annotationType.getSimpleName().toString();
                return ClassName.get(packageName, simpleName);
            }
        }

        // Default fallback
        return ClassName.get("org.jspecify.annotations", "Nullable");
    }

    private TypeMirror getTypeArgument(TypeMirror type, int index) {
        if (type.getKind() == TypeKind.DECLARED) {
            DeclaredType declaredType = (DeclaredType) type;
            List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();
            if (typeArguments.size() > index) {
                return typeArguments.get(index);
            }
        }
        return elementUtils.getTypeElement("java.lang.Object").asType();
    }

    private String capitalize(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
}
